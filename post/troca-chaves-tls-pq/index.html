<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Troca de chaves com TLS utilizando criptografia pós quântica - Rafael Begnini de Castilhos</title><meta name="gridsome:hash" content="dd35e2be7b007ce0c3d6e3dd715b9173e50f35f6"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Postagens de Rafael Begnini de Castilhos"><meta data-vue-tag="ssr" data-key="og:url" property="og:url" content="https://rafaelbcastilhos.github.io/undefined"><meta data-vue-tag="ssr" data-key="og:title" property="og:title" content="Troca de chaves com TLS utilizando criptografia pós quântica"><meta data-vue-tag="ssr" data-key="og:type" property="og:type" content="article"><meta data-vue-tag="ssr" data-key="og:description" property="og:description" content="undefined"><meta data-vue-tag="ssr" data-key="og:image" property="og:image" content=""><meta data-vue-tag="ssr" data-key="og:image:width" property="og:image:width" content=""><meta data-vue-tag="ssr" data-key="og:image:height" property="og:image:height" content=""><meta data-vue-tag="ssr" data-key="author" name="author" content="Rafael Begnini de Castilhos"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.c28a139992620b4971fd36d88a5c68b2.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.c28a139992620b4971fd36d88a5c68b2.png"><link rel="preload" href="/assets/css/0.styles.cf6f7cf5.css" as="style"><link rel="preload" href="/assets/js/app.02ac4b41.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.e609c002.js" as="script"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.7c544f8e.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.d0fa0be3.js"><link rel="prefetch" href="/assets/js/page--src--pages--posts-vue.b06697cf.js"><link rel="stylesheet" href="/assets/css/0.styles.cf6f7cf5.css"><script data-vue-tag="ssr" type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","datePublished":"28/07/2022","author":{"name":"rafaelbcastilhos"},"headline":"Troca de chaves com TLS utilizando criptografia pós quântica","image":""}</script><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div data-server-rendered="true" id="app" class="prose dark:prose-light md:container md:mx-auto md:px-48"><header class="px-7 flex justify-between items-center border-b md:border border-gray-200"><a href="/" class="active"><p>Rafael Begnini de Castilhos</p></a><div class="flex items-center"><a href="#" title="Toggle theme between light and dark" aria-label="Toggle theme between light and dark" class="text-gray-700 dark:text-gray-300 hover:text-gray-900 dark:hover:text-gray-100 mr-4"><span aria-hidden="true" role="img" class="material-design-icon brightness7-icon"><svg fill="currentColor" width="24" height="24" viewBox="0 0 24 24" class="material-design-icon__svg"><path d="M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z"><!----></path></svg></span></a><a href="/" class="active"><p class="mr-4">Sobre</p></a><a href="/posts/"><p>Postagens</p></a></div></header><div class="md:border-r md:border-l md:border-gray-200 text-justify"><div class="px-7 md:px-14 pt-7 md:pt-14"><h1>Troca de chaves com TLS utilizando criptografia pós quântica</h1><div class="flex items-center -mt-10"><p class="text-gray-500">28/07/2022</p></div></div><article class="justify-end px-7 md:px-14 pb-7 md:pb-14 text-justify"><h2 id="introdução"><a href="#introdu%C3%A7%C3%A3o" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Introdução</h2>
<p>Desde que se descobriu o potencial de criptoanálise do computador quântico,
especialmente com o algoritmo de Shor, criou-se a idéia de que a criptografia
moderna se tornaria inútil assim que esse tipo de computador começasse a ser
desenvolvido em larga escala. Com isso, todas as mensagens trocadas com o
uso de algoritmos criptográficos atuais seriam facilmente interceptáveis.</p>
<p>Desse modo, a troca de chaves que é um método de criptografia para trocas de chaves de maneira segura em canal público. Entretanto, deixaria de ser pois estaria utilizando um protocolo que poderia ser descriptografado por um computador quântico.</p>
<p>Em resposta a isso, surgiu a criptografia pós-quântica, ramo da criptografia que estuda classes de algoritmos criptográficos resistentes à criptoanálise quântica. Como exemplos de classes de algoritmos, podemos mencionar os baseados em hash, os baseados em látice, os baseados em códigos, entre outros. Estes algoritmos demorariam um tempo exponencial para serem quebrados, mesmo em computadores quânticos.</p>
<p>O TLS (Transport Layer Security) assim como o seu antecessor SSL(Secure Sockets Layer) é um protocolo de segurança projetado para fornecer segurança nas comunicações sobre uma rede de computadores. O protocolo TLS, que atualmente está na versão 1.2, visa principalmente fornecer privacidade e integridade de dados entre dois ou mais aplicativos de computador que se comunicam. Entretanto, com o surgimento da computação quântica, uma nova ameaça ao problemas de segurança surge.</p>
<p>Contextualizado os itens acima, em sequência será apresentado e experimentado a troca de chaves utilizando o protocolo TLS, será utilizado o projeto de código aberto Open Quantum Safe (OQS) que fornece algoritmos finalistas no NIST empacotados na biblioteca liboqs.</p>
<h2 id="conceitos"><a href="#conceitos" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Conceitos</h2>
<p>A troca de chave hı́brida refere-se ao uso de vários algoritmos de troca de
chave simultaneamente e à combinação do resultado com o objetivo de forne-
cer segurança, mesmo que todos os algoritmos do componente, exceto um, es-
tejam quebrados. É motivado pela transição para a criptografia pós-quântica.
Denominado como Transport Layer Security (TLS) versão 1.3.</p>
<p>Troca de chave ”hı́brida”, significa o uso de dois, ou mais algoritmos de troca de chave com base em diferentes suposições criptográficas, por exemplo, um algoritmo tradicional e um algoritmo de última geração. O principal objetivo é facilitar o estabelecimento de um segredo compartilhado que permaneça seguro enquanto um dos mecanismos de troca de chave permanecer intacto.</p>
<h3 id="encapsulamento"><a href="#encapsulamento" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Encapsulamento</h3>
<p>Os algoritmos de troca de chaves são formulados como mecanismos de en-
capsulamento de chaves, sendo eles:</p>
<ul>
<li>KeyGen: Geração probabilı́stica, chave pública pk e chave secreta sk.</li>
<li>Encaps: Encapsulamento probabilı́stico, recebe como entrada uma chave
pk, e gera um texto cifrado ct e segredo compartilhado ss.</li>
<li>Decaps: Desencapsulamento que recebe como entrada uma chave sk e
texto cifrado ct, gerando um texto compartilhado ss.</li>
</ul>
<h3 id="construção-da-troca"><a href="#constru%C3%A7%C3%A3o-da-troca" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Construção da troca</h3>
<ul>
<li>Negociação: Para cada combinação particular de algoritmos em um
troca de será representada por um grupo nomeado. Cada valor que
representa uma troca de chave corresponderá a um par ordenado de
dois algoritmos.</li>
<li>Transmissão: As mensagens serão concatenadas e transmitidas como
um único valor.</li>
<li>Cálculo de segredo compartilhado: Os dois segredos compartilhados são
concatenados. Inserindo no cronograma de chave no local do segredo
compartilhado (EC)DHE.</li>
</ul>
<p>A biblioteca liboqs fornece os principais mecanismos para encapsulamento
de chaves, conforme citado no item 2.1, sendo denotadas como:</p>
<ul>
<li>OQS KEM keypar: Gera um par de chaves pública/privada para
troca de chaves.</li>
<li>OQS KEM encaps: Gera uma chave pública para a outra parte e um
segredo compartilhado para o requisitante.</li>
<li>OQS KEM decaps: Gera um valor secreto compartilhado usando a
chave pública da outra parte e sua própria chave privada.</li>
</ul>
<p>Aplicando essas funcionalidades da biblioteca, é possı́vel encontrar o seguinte fluxo:</p>
<p><img src="https://raw.githubusercontent.com/rafaelbcastilhos/rafaelbcastilhos.github.io/master/post/images/troca-chave-tls-pq-fluxo.png" alt="Fluxograma"></p>
<h2 id="experimento"><a href="#experimento" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Experimento</h2>
<p>O experimento será executado em um notebook com sistema operacional Linux Ubuntu, todos os procedimentos citados a seguir também poderão ser executados em outros sistemas operacionais, porém haverá diferença em alguns comandos que são especiais do Linux. Preambularmente, iremos precisar realizar o download do programa Wireshark que é um programa que analisa o tráfego da rede e organiza por protocolos. Também iremos precisar baixar a biblioteca liboqs e a biblioteca wolfSSL.</p>
<h3 id="instalação-e-construção"><a href="#instala%C3%A7%C3%A3o-e-constru%C3%A7%C3%A3o" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Instalação e construção</h3>
<p>Para baixar o Wireshark é necessário executar:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">sudo apt-get install wireshark</span></span></code></pre>
<p>Após instalado, deve ser iniciado, executando o comando:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">sudo wireshark</span></span></code></pre>
<p>Para realizar download e construção do liboqs, execute:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">wget https://github.com/open-quantum-safe/liboqs/archive/refs/tags/0.7.0.tar.gz

tar xf 0.7.0.tar.gz

cd liboqs-0.7.0

mkdir build

cd build

cmake -DOQS_USE_OPENSSL=0 ..

make all

sudo make install</span></span></code></pre>
<p>Para realizar download e construção do wolfSSL, execute:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">git clone https://github.com/wolfssl/wolfssl

cd wolfssl

./autogen.sh

./configure --with-liboqs

make all

sudo make install</span></span></code></pre>
<h3 id="execução"><a href="#execu%C3%A7%C3%A3o" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Execução</h3>
<p>Em seguida, vamos estabelecer uma comunicação TLS entre um exemplo de servidor e um exemplo de cliente. Para isso, é necessário abrir duas janelas no terminal, uma para o servidor, outra para o cliente. Nesse momento, certifique-se que o Wireshark está aberto e clique no botão para iniciar captura de pacotes.</p>
<p>Agora é necessário especificar o inı́cio do servidor para troca de chaves
hı́bridas ECC-P521 e Kyber Level 5, em uma janela do terminal:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">./examples/server/server -v 4 --pqc P521_KYBER_LEVEL5</span></span></code></pre>
<p>Na outra janela do terminal, execute a conexão do cliente:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">./examples/client/client -v 4 --pqc P521_KYBER_LEVEL5</span></span></code></pre>
<p>O servidor e o cliente realizam uma conexão TLS e uma comunicação com mensagem de ida e volta. Cada janela exibe informações de conexão TLS 1.3 com as seguintes mensagens:</p>
<p><img src="https://raw.githubusercontent.com/rafaelbcastilhos/rafaelbcastilhos.github.io/master/post/images/troca-chave-tls-pq-servidor.png" alt="Servidor"></p>
<p><img src="https://raw.githubusercontent.com/rafaelbcastilhos/rafaelbcastilhos.github.io/master/post/images/troca-chave-tls-pq-cliente.png" alt="Cliente"></p>
<p>Após realizar a conexão, é possı́vel verificar os pacotes no Wireshark, filtrando apenas os pacotes que utilizam TLS, de acordo com a figura abaixo:</p>
<p><img src="https://raw.githubusercontent.com/rafaelbcastilhos/rafaelbcastilhos.github.io/master/post/images/troca-chave-tls-pq-wireshark.png" alt="Wireshark"></p>
<p>E também constatar o acontecimento do handshake, Client Hello e Server Hello, na imagem abaixo é demonstrado com detalhes as propriedades do TLS no pacote Server Hello:</p>
<p><img src="https://raw.githubusercontent.com/rafaelbcastilhos/rafaelbcastilhos.github.io/master/post/images/troca-chave-tls-pq-pacote.png" alt="Pacote Wireshark"></p>
<h2 id="análise-e-conclusões"><a href="#an%C3%A1lise-e-conclus%C3%B5es" aria-hidden="true"><span class="icon icon-link heading-anchor"></span></a>Análise e conclusões</h2>
<p>Portanto, após realizar testes e executar o programa de benchmark disponibilizado pela wolfSSL por meio do comando:</p>
<pre class="shiki" style="background-color: #2e3440ff"><code><span class="line"><span style="color: #d8dee9ff">./wolfcrypt/benchmark/benchmark</span></span></code></pre>
<p>Se torna possı́vel constatar que os tempos de processamento desses algoritmos
estão entrando em um intervalo comparável aos algoritmos atuais, mas ainda
não são iguais ou inferiores.</p>
<p>É possı́vel concluir que os segredos compartilhados calculados na troca
de chave hı́brida devem ser calculados de uma maneira que atinja a propriedade ”hı́brida”: o segredo resultante é seguro desde que pelo menos um dos algoritmos de troca de chave componente esteja intacto.</p>
</article><div id="comments" class="p-7 border-t border-gray-200"></div></div><footer class="text-sm px-7 flex items-center border-t md:border border-gray-200 text-center"><p class="text-center">ⓒ 2024. Rafael Begnini de Castilhos</p></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Troca de chaves com TLS utilizando criptografia pós quântica","date":"28\u002F07\u002F2022","content":"\u003Ch2 id=\"introdução\"\u003E\u003Ca href=\"#introdu%C3%A7%C3%A3o\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EIntrodução\u003C\u002Fh2\u003E\n\u003Cp\u003EDesde que se descobriu o potencial de criptoanálise do computador quântico,\nespecialmente com o algoritmo de Shor, criou-se a idéia de que a criptografia\nmoderna se tornaria inútil assim que esse tipo de computador começasse a ser\ndesenvolvido em larga escala. Com isso, todas as mensagens trocadas com o\nuso de algoritmos criptográficos atuais seriam facilmente interceptáveis.\u003C\u002Fp\u003E\n\u003Cp\u003EDesse modo, a troca de chaves que é um método de criptografia para trocas de chaves de maneira segura em canal público. Entretanto, deixaria de ser pois estaria utilizando um protocolo que poderia ser descriptografado por um computador quântico.\u003C\u002Fp\u003E\n\u003Cp\u003EEm resposta a isso, surgiu a criptografia pós-quântica, ramo da criptografia que estuda classes de algoritmos criptográficos resistentes à criptoanálise quântica. Como exemplos de classes de algoritmos, podemos mencionar os baseados em hash, os baseados em látice, os baseados em códigos, entre outros. Estes algoritmos demorariam um tempo exponencial para serem quebrados, mesmo em computadores quânticos.\u003C\u002Fp\u003E\n\u003Cp\u003EO TLS (Transport Layer Security) assim como o seu antecessor SSL(Secure Sockets Layer) é um protocolo de segurança projetado para fornecer segurança nas comunicações sobre uma rede de computadores. O protocolo TLS, que atualmente está na versão 1.2, visa principalmente fornecer privacidade e integridade de dados entre dois ou mais aplicativos de computador que se comunicam. Entretanto, com o surgimento da computação quântica, uma nova ameaça ao problemas de segurança surge.\u003C\u002Fp\u003E\n\u003Cp\u003EContextualizado os itens acima, em sequência será apresentado e experimentado a troca de chaves utilizando o protocolo TLS, será utilizado o projeto de código aberto Open Quantum Safe (OQS) que fornece algoritmos finalistas no NIST empacotados na biblioteca liboqs.\u003C\u002Fp\u003E\n\u003Ch2 id=\"conceitos\"\u003E\u003Ca href=\"#conceitos\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EConceitos\u003C\u002Fh2\u003E\n\u003Cp\u003EA troca de chave hı́brida refere-se ao uso de vários algoritmos de troca de\nchave simultaneamente e à combinação do resultado com o objetivo de forne-\ncer segurança, mesmo que todos os algoritmos do componente, exceto um, es-\ntejam quebrados. É motivado pela transição para a criptografia pós-quântica.\nDenominado como Transport Layer Security (TLS) versão 1.3.\u003C\u002Fp\u003E\n\u003Cp\u003ETroca de chave ”hı́brida”, significa o uso de dois, ou mais algoritmos de troca de chave com base em diferentes suposições criptográficas, por exemplo, um algoritmo tradicional e um algoritmo de última geração. O principal objetivo é facilitar o estabelecimento de um segredo compartilhado que permaneça seguro enquanto um dos mecanismos de troca de chave permanecer intacto.\u003C\u002Fp\u003E\n\u003Ch3 id=\"encapsulamento\"\u003E\u003Ca href=\"#encapsulamento\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EEncapsulamento\u003C\u002Fh3\u003E\n\u003Cp\u003EOs algoritmos de troca de chaves são formulados como mecanismos de en-\ncapsulamento de chaves, sendo eles:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EKeyGen: Geração probabilı́stica, chave pública pk e chave secreta sk.\u003C\u002Fli\u003E\n\u003Cli\u003EEncaps: Encapsulamento probabilı́stico, recebe como entrada uma chave\npk, e gera um texto cifrado ct e segredo compartilhado ss.\u003C\u002Fli\u003E\n\u003Cli\u003EDecaps: Desencapsulamento que recebe como entrada uma chave sk e\ntexto cifrado ct, gerando um texto compartilhado ss.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"construção-da-troca\"\u003E\u003Ca href=\"#constru%C3%A7%C3%A3o-da-troca\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EConstrução da troca\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003ENegociação: Para cada combinação particular de algoritmos em um\ntroca de será representada por um grupo nomeado. Cada valor que\nrepresenta uma troca de chave corresponderá a um par ordenado de\ndois algoritmos.\u003C\u002Fli\u003E\n\u003Cli\u003ETransmissão: As mensagens serão concatenadas e transmitidas como\num único valor.\u003C\u002Fli\u003E\n\u003Cli\u003ECálculo de segredo compartilhado: Os dois segredos compartilhados são\nconcatenados. Inserindo no cronograma de chave no local do segredo\ncompartilhado (EC)DHE.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EA biblioteca liboqs fornece os principais mecanismos para encapsulamento\nde chaves, conforme citado no item 2.1, sendo denotadas como:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EOQS KEM keypar: Gera um par de chaves pública\u002Fprivada para\ntroca de chaves.\u003C\u002Fli\u003E\n\u003Cli\u003EOQS KEM encaps: Gera uma chave pública para a outra parte e um\nsegredo compartilhado para o requisitante.\u003C\u002Fli\u003E\n\u003Cli\u003EOQS KEM decaps: Gera um valor secreto compartilhado usando a\nchave pública da outra parte e sua própria chave privada.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EAplicando essas funcionalidades da biblioteca, é possı́vel encontrar o seguinte fluxo:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Frafaelbcastilhos\u002Frafaelbcastilhos.github.io\u002Fmaster\u002Fpost\u002Fimages\u002Ftroca-chave-tls-pq-fluxo.png\" alt=\"Fluxograma\"\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"experimento\"\u003E\u003Ca href=\"#experimento\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EExperimento\u003C\u002Fh2\u003E\n\u003Cp\u003EO experimento será executado em um notebook com sistema operacional Linux Ubuntu, todos os procedimentos citados a seguir também poderão ser executados em outros sistemas operacionais, porém haverá diferença em alguns comandos que são especiais do Linux. Preambularmente, iremos precisar realizar o download do programa Wireshark que é um programa que analisa o tráfego da rede e organiza por protocolos. Também iremos precisar baixar a biblioteca liboqs e a biblioteca wolfSSL.\u003C\u002Fp\u003E\n\u003Ch3 id=\"instalação-e-construção\"\u003E\u003Ca href=\"#instala%C3%A7%C3%A3o-e-constru%C3%A7%C3%A3o\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EInstalação e construção\u003C\u002Fh3\u003E\n\u003Cp\u003EPara baixar o Wireshark é necessário executar:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003Esudo apt-get install wireshark\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EApós instalado, deve ser iniciado, executando o comando:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003Esudo wireshark\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EPara realizar download e construção do liboqs, execute:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003Ewget https:\u002F\u002Fgithub.com\u002Fopen-quantum-safe\u002Fliboqs\u002Farchive\u002Frefs\u002Ftags\u002F0.7.0.tar.gz\n\ntar xf 0.7.0.tar.gz\n\ncd liboqs-0.7.0\n\nmkdir build\n\ncd build\n\ncmake -DOQS_USE_OPENSSL=0 ..\n\nmake all\n\nsudo make install\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EPara realizar download e construção do wolfSSL, execute:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003Egit clone https:\u002F\u002Fgithub.com\u002Fwolfssl\u002Fwolfssl\n\ncd wolfssl\n\n.\u002Fautogen.sh\n\n.\u002Fconfigure --with-liboqs\n\nmake all\n\nsudo make install\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"execução\"\u003E\u003Ca href=\"#execu%C3%A7%C3%A3o\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EExecução\u003C\u002Fh3\u003E\n\u003Cp\u003EEm seguida, vamos estabelecer uma comunicação TLS entre um exemplo de servidor e um exemplo de cliente. Para isso, é necessário abrir duas janelas no terminal, uma para o servidor, outra para o cliente. Nesse momento, certifique-se que o Wireshark está aberto e clique no botão para iniciar captura de pacotes.\u003C\u002Fp\u003E\n\u003Cp\u003EAgora é necessário especificar o inı́cio do servidor para troca de chaves\nhı́bridas ECC-P521 e Kyber Level 5, em uma janela do terminal:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003E.\u002Fexamples\u002Fserver\u002Fserver -v 4 --pqc P521_KYBER_LEVEL5\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENa outra janela do terminal, execute a conexão do cliente:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003E.\u002Fexamples\u002Fclient\u002Fclient -v 4 --pqc P521_KYBER_LEVEL5\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EO servidor e o cliente realizam uma conexão TLS e uma comunicação com mensagem de ida e volta. Cada janela exibe informações de conexão TLS 1.3 com as seguintes mensagens:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Frafaelbcastilhos\u002Frafaelbcastilhos.github.io\u002Fmaster\u002Fpost\u002Fimages\u002Ftroca-chave-tls-pq-servidor.png\" alt=\"Servidor\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Frafaelbcastilhos\u002Frafaelbcastilhos.github.io\u002Fmaster\u002Fpost\u002Fimages\u002Ftroca-chave-tls-pq-cliente.png\" alt=\"Cliente\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EApós realizar a conexão, é possı́vel verificar os pacotes no Wireshark, filtrando apenas os pacotes que utilizam TLS, de acordo com a figura abaixo:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Frafaelbcastilhos\u002Frafaelbcastilhos.github.io\u002Fmaster\u002Fpost\u002Fimages\u002Ftroca-chave-tls-pq-wireshark.png\" alt=\"Wireshark\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EE também constatar o acontecimento do handshake, Client Hello e Server Hello, na imagem abaixo é demonstrado com detalhes as propriedades do TLS no pacote Server Hello:\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fraw.githubusercontent.com\u002Frafaelbcastilhos\u002Frafaelbcastilhos.github.io\u002Fmaster\u002Fpost\u002Fimages\u002Ftroca-chave-tls-pq-pacote.png\" alt=\"Pacote Wireshark\"\u003E\u003C\u002Fp\u003E\n\u003Ch2 id=\"análise-e-conclusões\"\u003E\u003Ca href=\"#an%C3%A1lise-e-conclus%C3%B5es\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link heading-anchor\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EAnálise e conclusões\u003C\u002Fh2\u003E\n\u003Cp\u003EPortanto, após realizar testes e executar o programa de benchmark disponibilizado pela wolfSSL por meio do comando:\u003C\u002Fp\u003E\n\u003Cpre class=\"shiki\" style=\"background-color: #2e3440ff\"\u003E\u003Ccode\u003E\u003Cspan class=\"line\"\u003E\u003Cspan style=\"color: #d8dee9ff\"\u003E.\u002Fwolfcrypt\u002Fbenchmark\u002Fbenchmark\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESe torna possı́vel constatar que os tempos de processamento desses algoritmos\nestão entrando em um intervalo comparável aos algoritmos atuais, mas ainda\nnão são iguais ou inferiores.\u003C\u002Fp\u003E\n\u003Cp\u003EÉ possı́vel concluir que os segredos compartilhados calculados na troca\nde chave hı́brida devem ser calculados de uma maneira que atinja a propriedade ”hı́brida”: o segredo resultante é seguro desde que pelo menos um dos algoritmos de troca de chave componente esteja intacto.\u003C\u002Fp\u003E\n"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.02ac4b41.js" defer></script><script src="/assets/js/page--src--templates--post-vue.e609c002.js" defer></script>
  </body>
</html>
